package types

// Code generated by mkenum. DO NOT EDIT.

// TweetFields defines optional Tweet field parameters.
type TweetFields struct {
	Attachments        bool // attachments
	AuthorID           bool // author_id
	ContextAnnotations bool // context_annotations
	ConversationID     bool // conversation_id
	CreatedAt          bool // created_at
	Entities           bool // entities
	Location           bool // geo
	InReplyTo          bool // in_reply_to_user_id
	Language           bool // lang
	NonPublicMetrics   bool // non_public_metrics
	OrganicMetrics     bool // organic_metrics
	Sensitive          bool // possibly_sensitive
	PromotedMetrics    bool // promoted_metrics
	PublicMetrics      bool // public_metrics
	Referenced         bool // referenced_tweets
	Source             bool // source
	Withheld           bool // withheld
}

// Label returns the parameter tag for optional Tweet fields.
func (TweetFields) Label() string { return "tweet.fields" }

// Values returns a slice of the selected field names from f.
func (f TweetFields) Values() []string {
	var values []string
	if f.Attachments {
		values = append(values, "attachments")
	}
	if f.AuthorID {
		values = append(values, "author_id")
	}
	if f.ContextAnnotations {
		values = append(values, "context_annotations")
	}
	if f.ConversationID {
		values = append(values, "conversation_id")
	}
	if f.CreatedAt {
		values = append(values, "created_at")
	}
	if f.Entities {
		values = append(values, "entities")
	}
	if f.Location {
		values = append(values, "geo")
	}
	if f.InReplyTo {
		values = append(values, "in_reply_to_user_id")
	}
	if f.Language {
		values = append(values, "lang")
	}
	if f.NonPublicMetrics {
		values = append(values, "non_public_metrics")
	}
	if f.OrganicMetrics {
		values = append(values, "organic_metrics")
	}
	if f.Sensitive {
		values = append(values, "possibly_sensitive")
	}
	if f.PromotedMetrics {
		values = append(values, "promoted_metrics")
	}
	if f.PublicMetrics {
		values = append(values, "public_metrics")
	}
	if f.Referenced {
		values = append(values, "referenced_tweets")
	}
	if f.Source {
		values = append(values, "source")
	}
	if f.Withheld {
		values = append(values, "withheld")
	}
	return values
}

// NeedUserContext reports whether any selected Tweet fields require
// user-context access.
func (f TweetFields) NeedUserContext() bool {
	return f.NonPublicMetrics || f.OrganicMetrics || f.PromotedMetrics
}

// Tweets is a searchable slice of Tweet values.
type Tweets []*Tweet

// FindByID returns the first Tweet in ts whose ID matches, or nil.
func (ts Tweets) FindByID(id string) *Tweet {
	for _, v := range ts {
		if v.ID == id {
			return v
		}
	}
	return nil
}

// UserFields defines optional User field parameters.
type UserFields struct {
	CreatedAt       bool // created_at
	Description     bool // description
	Entities        bool // entities
	FuzzyLocation   bool // location
	PinnedTweetID   bool // pinned_tweet_id
	ProfileImageURL bool // profile_image_url
	Protected       bool // protected
	PublicMetrics   bool // public_metrics
	ProfileURL      bool // url
	Verified        bool // verified
	Withheld        bool // withheld
}

// Label returns the parameter tag for optional User fields.
func (UserFields) Label() string { return "user.fields" }

// Values returns a slice of the selected field names from f.
func (f UserFields) Values() []string {
	var values []string
	if f.CreatedAt {
		values = append(values, "created_at")
	}
	if f.Description {
		values = append(values, "description")
	}
	if f.Entities {
		values = append(values, "entities")
	}
	if f.FuzzyLocation {
		values = append(values, "location")
	}
	if f.PinnedTweetID {
		values = append(values, "pinned_tweet_id")
	}
	if f.ProfileImageURL {
		values = append(values, "profile_image_url")
	}
	if f.Protected {
		values = append(values, "protected")
	}
	if f.PublicMetrics {
		values = append(values, "public_metrics")
	}
	if f.ProfileURL {
		values = append(values, "url")
	}
	if f.Verified {
		values = append(values, "verified")
	}
	if f.Withheld {
		values = append(values, "withheld")
	}
	return values
}

// NeedUserContext reports whether any selected User fields require
// user-context access.
func (f UserFields) NeedUserContext() bool { return false }

// Users is a searchable slice of User values.
type Users []*User

// FindByID returns the first User in us whose ID matches, or nil.
func (us Users) FindByID(id string) *User {
	for _, v := range us {
		if v.ID == id {
			return v
		}
	}
	return nil
}

// FindByUsername returns the first User in us whose Username matches, or nil.
func (us Users) FindByUsername(username string) *User {
	for _, v := range us {
		if v.Username == username {
			return v
		}
	}
	return nil
}

// MediaFields defines optional Media field parameters.
type MediaFields struct {
	Attachments      bool // attachments
	Duration         bool // duration_ms
	Height           bool // height
	NonPublicMetrics bool // non_public_metrics
	OrganicMetrics   bool // organic_metrics
	PreviewImageURL  bool // preview_image_url
	PromotedMetrics  bool // promoted_metrics
	PublicMetrics    bool // public_metrics
	Width            bool // width
}

// Label returns the parameter tag for optional Media fields.
func (MediaFields) Label() string { return "media.fields" }

// Values returns a slice of the selected field names from f.
func (f MediaFields) Values() []string {
	var values []string
	if f.Attachments {
		values = append(values, "attachments")
	}
	if f.Duration {
		values = append(values, "duration_ms")
	}
	if f.Height {
		values = append(values, "height")
	}
	if f.NonPublicMetrics {
		values = append(values, "non_public_metrics")
	}
	if f.OrganicMetrics {
		values = append(values, "organic_metrics")
	}
	if f.PreviewImageURL {
		values = append(values, "preview_image_url")
	}
	if f.PromotedMetrics {
		values = append(values, "promoted_metrics")
	}
	if f.PublicMetrics {
		values = append(values, "public_metrics")
	}
	if f.Width {
		values = append(values, "width")
	}
	return values
}

// NeedUserContext reports whether any selected Media fields require
// user-context access.
func (f MediaFields) NeedUserContext() bool {
	return f.NonPublicMetrics || f.OrganicMetrics || f.PromotedMetrics
}

// Medias is a searchable slice of Media values.
type Medias []*Media

// FindByKey returns the first Media in ms whose Key matches, or nil.
func (ms Medias) FindByKey(key string) *Media {
	for _, v := range ms {
		if v.Key == key {
			return v
		}
	}
	return nil
}

// PollFields defines optional Poll field parameters.
type PollFields struct {
	Attachments  bool // attachments
	Duration     bool // duration_minutes
	EndTime      bool // end_datetime
	VotingStatus bool // voting_status
}

// Label returns the parameter tag for optional Poll fields.
func (PollFields) Label() string { return "poll.fields" }

// Values returns a slice of the selected field names from f.
func (f PollFields) Values() []string {
	var values []string
	if f.Attachments {
		values = append(values, "attachments")
	}
	if f.Duration {
		values = append(values, "duration_minutes")
	}
	if f.EndTime {
		values = append(values, "end_datetime")
	}
	if f.VotingStatus {
		values = append(values, "voting_status")
	}
	return values
}

// NeedUserContext reports whether any selected Poll fields require
// user-context access.
func (f PollFields) NeedUserContext() bool { return false }

// Polls is a searchable slice of Poll values.
type Polls []*Poll

// FindByID returns the first Poll in ps whose ID matches, or nil.
func (ps Polls) FindByID(id string) *Poll {
	for _, v := range ps {
		if v.ID == id {
			return v
		}
	}
	return nil
}

// PlaceFields defines optional Place field parameters.
type PlaceFields struct {
	Attachments bool // attachments
	ContainedIn bool // contained_within
	CountryName bool // country
	CountryCode bool // country_code
	Location    bool // geo
	Name        bool // name
	Type        bool // place_type
}

// Label returns the parameter tag for optional Place fields.
func (PlaceFields) Label() string { return "place.fields" }

// Values returns a slice of the selected field names from f.
func (f PlaceFields) Values() []string {
	var values []string
	if f.Attachments {
		values = append(values, "attachments")
	}
	if f.ContainedIn {
		values = append(values, "contained_within")
	}
	if f.CountryName {
		values = append(values, "country")
	}
	if f.CountryCode {
		values = append(values, "country_code")
	}
	if f.Location {
		values = append(values, "geo")
	}
	if f.Name {
		values = append(values, "name")
	}
	if f.Type {
		values = append(values, "place_type")
	}
	return values
}

// NeedUserContext reports whether any selected Place fields require
// user-context access.
func (f PlaceFields) NeedUserContext() bool { return false }

// Places is a searchable slice of Place values.
type Places []*Place

// FindByID returns the first Place in ps whose ID matches, or nil.
func (ps Places) FindByID(id string) *Place {
	for _, v := range ps {
		if v.ID == id {
			return v
		}
	}
	return nil
}
